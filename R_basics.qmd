---
title: "Basics of R"
format: html
editor: visual
---

This section is intended to provide a very bare bones explanation of how to do some things in R.

It covers some basic methods including reading and writing data, manipulating and reshaping datasets with tidyverse verbs and drawing some simple charts with ggplot2. For much better resources, please use <https://r4ds.hadley.nz/> which is awesome.

This is a work in progress.

## Load Libraries

Libraries (also known as packages) allow R to do things it can't do out of the box.\
You can install packages using the `install.packages("packagename")` syntax. If you haven't used R before then you should first install the tidyverse packages by typing `install.packages("tidyverse")`

You should always load the libraries you'll be using at the top of your script.

```{r}

library(tidyverse)
```

## Write CSV files

We'll be using the iris dataset, which is built in and which can be accessed by typing `iris`.

We need a toy dataset to work with, so let's start by saving a copy of `iris` as a csv file. This is backwards from what we normally do, which is to save a data set at the end, but will serve our purpose here.

```{r}

write_csv(iris, "iris.csv")  # Saving to CSV

```

Check that it appears in the files list on the right

## Read CSV files

Next let's read the file back in and assign it to a data frame

The `<-` symbol assigns the data contained in the file to an **object** in the R environment.

You can have as many or as few objects as you need.

```{r}

iris_data <- read_csv("iris.csv")
```

The messages are important. Check which variables have been assigned to which **class**

-   **chr**:

    -   Full Form: **character**

    -   Used for columns containing text data (strings).

-   **dbl or num**:

    -   Full Form: **double/number**

    -   Represents floating-point numbers (numeric values with decimal places).

    -   This is the most common numeric data type used in R for real numbers.

-   **int**:

    -   Full Form: **integer**

    -   Used for whole numbers.

-   **lgl**:

    -   Full Form: **logical**

    -   Used for boolean (TRUE/FALSE) values.

-   **fct**:

    -   Full Form: **factor**

    -   Used for categorical data (discrete values like categories, levels, or groups).

-   **dttm**:

    -   Full Form: **date-time**

    -   Represents date and time objects (POSIXct class) which include both date and time information.

-   **date**:

    -   Full Form: **Date**

    -   Used for date objects, containing only date information (year, month, day).

-   **time**:

    -   Full Form: **time**

    -   Used for time objects (sometimes seen when working with time series data, though less common than date or POSIXct).

-   **lst**:

    -   Full Form: **list**

    -   Represents a list column, which can hold any type of R object, including vectors, data frames, or even other lists.

## Look at the structure of an object

```{r}
str(iris_data)
```

## Look at the contents of an object

```{r}
iris_data
```

### Summary of the data set

```{r}
summary(iris_data)
```

## Pipes

The **`%>%`** pipe operator, commonly called the "pipe," is one of the most important tools in the **tidyverse**. It is used to pass the result of one function into the next function, making your code cleaner and easier to read by chaining operations together.

### How the Pipe Works:

The pipe takes the output of the expression on its left and passes it as the **first argument** to the function on its right.

$$ \texttt{result} \leftarrow \texttt{data} \\ \hspace{2cm} \% \! > \! \% \, \texttt{operation}_1 \\ \hspace{2cm} \% \! > \! \% \, \texttt{operation}_2 \\ \hspace{2cm} \vdots \\ \hspace{2cm} \% \! > \! \% \, \texttt{operation}_n$$

### Simple Explanation:

-   Without the pipe, you would need to **nest** functions, which can make the code harder to read:

`summarise(group_by(filter(df, Species == "setosa"), Species), mean_length = mean(Sepal.Length))`

-   With the **`%>%`** pipe, you can write it more **readable** by breaking each step down:

    ```{r}

    iris_data %>%
      filter(Sepal.Length >5.8) %>%
      group_by(Species) %>%
      summarise(mean_length = mean(Sepal.Length))


    ```

### Benefits of Using the Pipe:

-   **Improves readability**: It reads like a logical sequence of steps.

-   **Reduces the need for intermediate variables**: You don’t need to create multiple intermediate objects.

-   **Simplifies function chaining**: Functions are applied one after the other, making it clear what happens at each step.

## Single Table Verbs (basic)

All the main actions in tidyverse take a tibble (the new name for a dataframe), do something with it and then return another tibble. These are the 'single table verbs'.

-   These are the main functions you'll need to learn.

-   All of them accept lists, where you separate items with a comma.

### Filter

-   **`filter()`**:

    -   Filters rows based on specified conditions.

    -   Returns only the rows that meet the condition(s).

```{r}
iris_data %>% 
  filter(
    Species == "setosa",
    Sepal.Length > 4.3)
```

### Logic

-   You can provide `logical operators`\` to any verb to make complex queries

    -   `==` Equals

    -   != Not Equals

    -   `>` more than

    -   `<` less than

    -   `>=` more than or equal to

    -   `<=` less than or equal to

    -   `|` or

    -   `&` and

    -   `!` not

    -   `+` add

    -   `-` subtract

    -   `%%` modulo

### AND (&)

Filtering rows where Sepal.Length is greater than 5 AND Species is not setosa

```{r}

iris_data %>% 
  filter(
    Sepal.Length > 5 & Species != "setosa"
    )

```

### OR (\|)

Filtering rows where Sepal.Length is less than 5 OR Species is setosa

```{r}

iris_data %>% 
  filter(
    Sepal.Length < 5 | Species == "setosa"
    )

```

### NOT (!)

Filtering rows where Species is NOT "setosa" by negating the test with `!` placed at the start. Compare to above where `!=` was used for `not-equal`. Here it tests if the species equals setosa, then returns all rows where that is NOT true.

```{r}

iris_data %>% 
  filter(
    !(Species == "setosa")
    )


```

### 

### Arrange

-   **`arrange()`**:

    -   Orders rows of a tibble by one or more columns.

    -   Can sort in ascending or descending order.

    -   Using a `list` will sort by item 1, then item 2, then item 3.

    -   As with filter, this function can accept a list of actions that are carried out sequentially

```{r}

iris_data %>% 
  arrange(
    Sepal.Length,
    Sepal.Width,
    Species
    )
```

```{r}
iris_data %>% 
  arrange(
    !Sepal.Length,
    Sepal.Width,
    Species
    )
```

### Select

-   **`select()`**:

    -   Selects specific columns from a data frame or tibble.

    -   Useful for reducing data to only the columns of interest.

    -   As with other verbs, a sequential set of actions is possible

```{r}
iris_data %>% 
  select(
    Sepal.Length, 
    Species
    )

```

-   It's also possible to negate an action,

```{r}
iris_data %>% 
  select(
    !Species
    )
```

### Mutate

-   **`mutate()`**:

    -   Adds new columns or modifies existing columns in a tibble.

    -   Commonly used for creating calculated columns.

```{r}
iris_data %>%
  mutate(
    Petal.Ratio = Petal.Length / Petal.Width,
    Petal.Area = Petal.Length * Petal.Width
         )
```

### Pivot_longer

-   **`pivot_longer()`**:

    -   Converts wide data to long format (stacking columns into rows).

    -   Useful for transforming data when working with multiple measurement columns.

    -   We'll use `relig_income` as an example data set. This is in WIDE format.

```{r}
relig_income
```

-   To pivot this data set, we provide

    -   `cols =` : The columns that will be used to pivot in to the new 'values' column. Here we want all columns from the dataset except the `religion` column which provides the labels, so simply exclude that one with `!religion`. You could also specify specific columns with a list `cols = c("<$10k","$10-20k","$20-30k")`

```{r}
relig_income_long <- relig_income %>%
    pivot_longer(
      cols = !religion, 
      names_to = "income", 
      values_to = "n")

relig_income_long


```

### Pivot_wider

This is the exact opposite of pivot_longer. You'll be taking the values of a column (here `income`) that you want to pivot to be the new column `names` in the wide format tibble, then distributing the `values` of another column (here `count`) to the appropriate columns and rows (here `religion`).

```{r}
relig_income_long %>%
  pivot_wider(
    id_cols = religion,
    names_from = income, 
    values_from = n
    )

```

### Using pipes and verbs together

To do a series of things to a tibble, you simply pipe the verbs

```{r}

relig_income %>%
    pivot_longer(  
      cols = !religion, 
      names_to = "income", 
      values_to = "count") %>% 

    filter(
      income != "Don't know/refused"
          ) %>% 

    arrange(
      income,
      religion
          )

```

-   You can include notes if it helps you.

-   Using indentation also really helps

```{r}

relig_income %>%
  
    # Pivot the table to be long format
    pivot_longer(  
      cols = !religion, 
      names_to = "income", 
      values_to = "count") %>% 
  
    # Remove lines where no income data was provided
    filter(
      income != "Don't know/refused"
          ) %>% 
  
    # Sort the data to sho 
    arrange(
      income,
      religion
          )
```

### Group_by & Summarise

-   These verbs create a data frame with one row per `group`, where the variables are a summary of values.

<!-- -->

-   **`group_by()`**:

    -   Groups data by one or more columns, often used in conjunction with `summarise()` for grouped operations.

<!-- -->

-   **`summarise()`**:

    -   Creates summary statistics for each group, such as mean, median, or sum.

    -   Often used after `group_by()` to apply a function to each group.

```{r}

iris %>%
  group_by(Species) %>%
  summarise(
    mean.sepal.length = mean(Sepal.Length),
    median.petal.length = median(Petal.Length)
            )
```

### Reframe

-   **Purpose**: A more flexible way to return multiple results for each group without reducing it to one row per group.

-   **Typical Use**: Used when you want to keep multiple rows per group but still perform summary operations.

-   **Behavior**: Allows for returning multiple rows or multiple values for each group, so it doesn’t necessarily collapse the data.

```{r}
iris %>%
  group_by(Species) %>%
  reframe(
    sepal_length_range = range(Sepal.Length),
    count = n(),
    mean.sepal.length = mean(Sepal.Length)
  )
```

#### When to use summarise or reframe

-   **Use `summarise()`** when you want to condense the data down to a single row per group or perform a single calculation for each group.

-   **Use `reframe()`** when you need more flexibility in your summaries, like returning multiple rows or when you don't necessarily want to collapse the data into a single row per group.

In most common cases, `summarise()` is appropriate when working with grouped data, but `reframe()` can be handy for more complex summary needs.

### Rename

-   **`rename()`**:

    -   Renames columns in a tibble.

    -   Helpful for cleaning up column names for clarity.

```{r}

iris %>% 
  rename(
    var_a = Petal.Length,
    var_b = Petal.Width
    )
```

### Joining

-   **`left_join()` / `right_join()` / `inner_join()` / `full_join()`**:\\

Joins add columns from one tibble to another, matching the observations using key variables.

There are three types of join

-   A `left_join()` keeps all observations in `x`.

-   A `right_join()` keeps all observations in `y`.

-   A `full_join()` keeps all observations in `x` and `y`.

We'll use the `band_members` and `band_instruments` data frames for this

```{r}
band_members
```

```{r}
band_instruments
```

You can see that both tibbles contain two variables, of which one is called `name`. This will be the **key variable** that is used for joining. R will automatically look for matching variables, and will merge the data semi-automatically. It even works if there's more than one key variable.

#### Left join

```{r}

left_join(
  band_members,
  band_instruments
)
```

You can see that the new left_joined tibble now contains three variables.

All three band members who were in the `band_members` tibble are still represented here, but `Keith` is not included in this tibble because `left_join` adds new columns to observations that already exist in `band_members`

#### Right Join

The `right_join` works in exactly the opposite way. Here the `right_join` adds new columns to the observations of the right hand tibble (i.e. to band_instruments).

```{r}

right_join(
  band_members,
  band_instruments
)
```

#### Full Join

The `full_join` keeps all the observations and all the columns of both data sets.

```{r}
full_join(
  band_members,
  band_instruments
)
```

### Separate wider

```{r}
df <- tibble(id = 1:3, patient_id = c("m-123", "f-455", "f-123"))
df

```

There are three basic ways to split up a string into pieces

#### With a delimiter

```{r}
df %>% 
  separate_wider_delim (
    patient_id, 
    delim = "-", 
    names = c("gender", "unit")
    )

```

#### By string length

Here you provide a set of widths to map new columns to various characters.

The example data are in the form `m-123` where the `m` represents gender, the `-` is just a delimiter and the `123` is the participant ID.

we can assign characters with `var = n` where n is the width of the string in characters.

`widths = c(gender = 1)`

-   will assign the first character in the strong to a new variable `gender.`

`widths = c(gender = 1, 1)`

-   Assigns the first character in the strong to a new variable `gender.`

-   The next character will be dropped

`widths = c(gender = 1, 1, unit=3)`

-   Assigns the first character in the strong to a new variable `gender.`

-   The next character will be dropped

-   Finally assigns the last 3 characters to a new variable `unit`

#### Or by REGEX

Regular expressions are a poweful language for string matching.

```{r}
df %>% 
  separate_wider_regex(
    patient_id, c(gender = ".", ".", unit = "\\d+"))

```

A full example is like this

```{r}
df %>% 
  separate_wider_position (
    cols = patient_id,
    widths = c(gender = 1, 1, unit=3))
   
```

### Unite

Unite joins columns, or merges them.

```{r}
df <- expand_grid(x = c("a", NA), y = c("b", NA))
df
```

#### Unite, dropping NAs

```{r}
df %>% 
  unite(
    "z",
    x:y,
    na.rm = FALSE,
    remove = FALSE)
```

#### Unite, removing originals and shirt

```{r}
df %>% 
  unite(
    "z",
    x:y, 
    na.rm = TRUE,
    remove = FALSE
    )
```

### Summary of Exclusive Helper Functions:

-   **Conditional Operations**: `case_when()`, `if_else()`

-   **Range Check**: `between()`

-   **Missing Value Handling**: `coalesce()`, `is.na()`

-   **Cumulative Functions**: `cumsum()`, `cummean()`, `cumall()`, `cumany()`

-   **Row-based Operations**: `lag()`, `lead()`, `nth()`, `row_number()`

-   **Summarizing or Counting**: `n()`, `pmin()`, `pmax()`, `any()`, `all()`

These helper functions are used specifically within verbs like `mutate()`, `filter()`, `summarise()`, `arrange()`, and others to perform specialized operations inside the context of a single table.

### Case_when

### 
